// @author jli@cparta.se

package main

import (
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path"
	"regexp"
	"strconv"
	"strings"
	"time"
)

const (
	errSuccess = iota
	errGitNotFound
	errTagInvalid
	errBuildNumberInvalid
	errReleaseNotOnDefault
	errFailedToCreateOut
	errFailedToWriteOutput
	errPackageNameInvalid
)

var (
	gitBin      = ""
	flagName    = flag.String("name", "", "write Go source with given package name")
	flagOut     = flag.String("out", "", "file to write to (defaults to stdout)")
	flagGit     = flag.String("git", "git", "name of Git executable")
	flagRelease = flag.Bool("release", false, "output release version without build info suffix")
	reCheckTag  = regexp.MustCompile(`^v\d+\.\d+\.\d+$`)
	reOnlyWords = regexp.MustCompile(`[^\w]`)
)

func getTag() (tag string) {
	tag = strings.TrimSpace(os.Getenv("CI_COMMIT_TAG"))
	if tag == "" {
		if b, _ := exec.Command(gitBin, "describe", "--exact-match", "--abbrev=0").Output(); len(b) > 0 {
			tag = strings.TrimSpace(string(b))
		} else {
			tag = "v0.0.0"
		}
	}
	if !reCheckTag.MatchString(tag) {
		fmt.Fprintf(os.Stderr, "tag doesn't match 'vN.N.N': '%s'\n", tag)
		os.Exit(errTagInvalid)
	}
	return
}

func isDefaultBranch(branch string) bool {
	if defBranch, ok := os.LookupEnv("CI_DEFAULT_BRANCH"); ok {
		return branch == strings.TrimSpace(defBranch)
	}
	switch branch {
	case "default":
		return true
	case "master":
		return true
	case "main":
		return true
	}
	return false
}

func getBranch() (branch, orgBranch string) {
	orgBranch = strings.TrimSpace(os.Getenv("CI_COMMIT_REF_NAME"))
	if orgBranch == "" {
		if b, _ := exec.Command(gitBin, "rev-parse", "--abbrev-ref", "HEAD").Output(); len(b) > 0 {
			orgBranch = strings.TrimSpace(string(b))
		}
	}

	if !isDefaultBranch(orgBranch) {
		branch = orgBranch
		if orgBranch != "HEAD" {
			branch = strings.ReplaceAll(strings.ToLower(reOnlyWords.ReplaceAllString(branch, "-")), "--", "-")
		}
	}

	return
}

func getBuild() (build, buildSource string) {
	build = strings.TrimSpace(os.Getenv("CI_PIPELINE_IID"))
	if build == "" {
		if b, _ := exec.Command(gitBin, "rev-list", "HEAD", "--count").Output(); len(b) > 0 {
			build = strings.TrimSpace(string(b))
			buildSource = "git commit count"
		}
	} else {
		buildSource = "GitLab CI_PIPELINE_IID"
	}

	if num, err := strconv.Atoi(build); err != nil {
		fmt.Fprintf(os.Stderr, "failed to parse build number '%s': %s\n", build, err)
		os.Exit(errBuildNumberInvalid)
	} else if num < 1 {
		fmt.Fprintf(os.Stderr, "build number %d is less than 1\n", num)
		os.Exit(errBuildNumberInvalid)
	}

	return
}

func main() {
	var err error

	flag.Parse()

	if gitBin, err = exec.LookPath(*flagGit); err != nil {
		fmt.Fprintf(os.Stderr, "git executable not found: '%s'\n", err)
		os.Exit(errGitNotFound)
	}

	pkgName := strings.ToLower(reOnlyWords.ReplaceAllString(*flagName, ""))
	if pkgName != *flagName {
		fmt.Fprintf(os.Stderr, "package name '%s' is invalid\n", *flagName)
		os.Exit(errPackageNameInvalid)
	}

	fileName := *flagOut

	version := getTag()
	build, buildSource := getBuild()
	branch, orgBranch := getBranch()

	if *flagRelease {
		if branch != "" {
			fmt.Fprintf(os.Stderr, "release version must be on default branch, not '%s'\n", orgBranch)
			os.Exit(errReleaseNotOnDefault)
		}
	} else {
		version += "-"
		if branch != "" {
			version += branch + "."
		}
		version += build
	}

	outputFile := os.Stdout
	outputText := version + "\n"

	if len(fileName) > 0 {
		if outputFile, err = os.Create(fileName); err != nil {
			fmt.Fprintf(os.Stderr, "failed to create '%s': %s\n", fileName, err)
			os.Exit(errFailedToCreateOut)
		}
		defer outputFile.Close()
	}

	executable, _ := os.Executable()
	executable = path.Base(executable)
	if len(pkgName) > 0 {
		outputText = fmt.Sprintf(`// generated by %s at %s
// branch %s, %s %s
package %s

const Version = %s
`,
			executable, time.Now().Format(time.ANSIC),
			strconv.Quote(orgBranch), buildSource, build,
			pkgName,
			strconv.QuoteToASCII(version))
	}

	if _, err = outputFile.WriteString(outputText); err != nil {
		fmt.Fprintf(os.Stderr, "failed to write output: %s\n", err)
		os.Exit(errFailedToWriteOutput)
	}

	os.Exit(errSuccess)
}
